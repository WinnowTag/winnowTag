# Copyright (c) 2005 The Kaphan Foundation
#
# Possession of a copy of this file grants no permission or license
# to use, modify, or create derivate works.
# Please contact info@peerworks.org for further information.
#

require 'taggable'
require 'tag'

# Need to manually require feed_item since the winnow_feed plugin  defines
# these classes the auto-require functionality of Rails doesn't try to load the Winnow 
# additions to these classes.
load_without_new_constant_marking File.join(RAILS_ROOT, 'vendor', 'plugins', 'winnow_feed', 'lib', 'feed_item.rb')

# Provides a representation of an item from an RSS/Atom feed.
#
# This class includes methods for:
#
# * Finding items based on taggings and other filters.
# * Extracting an item from a FeedTools::Item object.
# * Getting and producing the tokens for a feed item.
#
# The FeedItem class only stores summary metadata for a feed item, the actual
# content is stored in the FeedItemContent class. This enables faster database
# access on the smaller summary records and allows us to use a MyISAM table for
# the content which can then be index using MySQL's Full Text Indexing.
#
# Tokens are stored in a FeedItemTokensContainer.
#
# The original XML data is stored in a FeedItemXmlData.
#
# See also FeedItemContent, FeedItemXmlData and FeedItemTokensContainer.
# 
# == Schema Information
# Schema version: 57
#
# Table name: feed_items
#
#  id             :integer(11)   not null, primary key
#  feed_id        :integer(11)   
#  sort_title     :string(255)   
#  time           :datetime      
#  created_on     :datetime      
#  unique_id      :string(255)   default("")
#  time_source    :string(255)   default("unknown")
#  xml_data_size  :integer(11)   
#  link           :string(255)   
#  content_length :integer(11)   
#  position       :integer(11)   
#

class FeedItem < ActiveRecord::Base
  acts_as_taggable  
  
  # Finds some random items with their tokens.  
  #
  # Instead of using order by rand(), which is very slow for large tables,
  # we use a modified version of the method described at http://jan.kneschke.de/projects/mysql/order-by-rand/
  # to get a random set of items. The trick here is to generate a list of random ids 
  # by multiplying rand() and max(position). This list is then joined with the feed_items table
  # to get the items.  Generating this list is very fast since MySQL can do it without accessing
  # the tables or indexes at all.
  #
  # We use the position column to randomize since that is guarenteed to not have any holes
  # and to have even distribution.
  #
  def self.find_random_items_with_tokens(size)
    self.find(:all,
      :select => "feed_items.id, fitc.tokens_with_counts as tokens_with_counts",
      :joins => "inner join random_backgrounds as rnd on feed_items.id = rnd.feed_item_id " +
                "inner join feed_item_tokens_containers as fitc on fitc.feed_item_id = feed_items.id" + 
                " and fitc.tokenizer_version = #{FeedItemTokenizer::VERSION}",
      :limit => size)
  end
  
  # Gets a count of the number of items that meet conditions applied by the filters.
  #
  # See options_for_filters.
  def self.count_with_filters(filters = {})
    options = options_for_filters(filters)
    options[:select] = 'distinct feed_items.id'
    options.delete(:limit)
    options.delete(:offset)
    FeedItem.count(options)
  end
  
  # Performs a find(:all) using the options generated by passing the filters argument to 
  # options_for_filters.
  #
  # When a user is provided in the filters hash this method will also do some prefetching of
  # the user and classifier taggings for the items loaded. This uses the caching mechanism
  # provided by the FindByTagger module.  The advantage of this is that you no longer need 
  # N + 1 queries to get the taggings for each item, instead there are just 3 queries, one 
  # to get the items and one each to get the taggings for the user and user's classifier.
  #
  # Note: The Rails eager loading mechanism can't substitute for this custom solution because
  # of the complexity of the joining in the query produced by options_with_filters.
  #
  def self.find_with_filters(filters = {})    
    feed_items = FeedItem.find(:all, options_for_filters(filters).merge(:select => 'distinct feed_items.id, feed_items.time,' +
                                                                      ' feed_items.link, feed_items.sort_title,' +
                                                                      ' feed_items.feed_id, feed_items.created_on'))
    
    if user = filters[:view].user
      feed_item_ids = feed_items.map(&:id)
      user_taggings = user.taggings.find(:all, :conditions => ['taggings.taggable_id in (?)', feed_item_ids], :include => :tag)
      classifier_taggings = user.classifier.taggings.find(:all, :conditions => ['taggings.taggable_id in (?)', feed_item_ids], :include => :tag)
      
      user_taggings.each {|t| t.set_tagger_target(user)}
      classifier_taggings.each {|t| t.set_tagger_target(user.classifier)}
      
      feed_items.each do |feed_item|
        user_taggings_for_item = user_taggings.select do |tagging|          
          tagging.taggable_id == feed_item.id
        end
        classifier_taggings_for_item = classifier_taggings.select do |tagging|
          tagging.taggable_id == feed_item.id
        end
        
        feed_item.taggings.cached_taggings.merge!(user => user_taggings_for_item, user.classifier => classifier_taggings_for_item)
      end
    end
    
    feed_items
  end
  
  # This builds the SQL to use for the find_with_filters and count_with_filters methods.
  #
  # The SQL is pretty complex, I had a go at trying to find a nicer way to generate it, as opposed
  # to building up two big strings, one for join conditions and one for where conditions.  I tried
  # SQLDSL except it turned out to be just as verbose and harder to read due to all the conditionals. So I
  # have settled for string concatenation with (hopefully) good documentation.
  #
  # === Parameters
  #
  # A Hash with thiese keys (all optional):
  #
  # <tt>:feed_filter</tt>:: Constrains returned items to be members of a given feed. (Should be the id of the feed)
  # <tt>:only_latest</tt>:: (true|false) If true only items collected in the latest collection of the feed will be returned.
  # <tt>:tag_filter</tt>:: Constrains returned items to be tagged with the provided tag. <tt>:user</tt> should also be provided.
  # <tt>:user</tt>:: Required for :tag_filter. Constrains taggings that meet the tag_filter to have the user or their classifier as the tagger. 
  # <tt>:only_tagger</tt>:: Can be 'user' or 'classifier'.  Constrains the type of tagger in a tag filter to user or classifier.
  # <tt>:include_negative</tt>:: (true|false) If true negative taggings will be included in a tag_filters results. Default is false.
  # <tt>:text_filter</tt>:: Constrains items that contain a sub-string. Uses MySQL full text index on title, author and description.
  # 
  # Also supports <tt>:limit</tt>, <tt>:offset</tt> and <tt>:order</tt> as defined by ActiveRecord::Base.find
  #
  # This will return a Hash of options suitable for passing to FeedItem.find.
  # 
  def self.options_for_filters(filters) # :doc:
    filters.assert_valid_keys(:limit, :order, :offset, :view, :only_tagger, :include_negative)
    options = {:limit => filters[:limit], :order => filters[:order], :offset => filters[:offset]}
    view = filters[:view]

    joins = []
    conditions = []
    
    add_feed_filter_conditions!(view.feed_filter, conditions)
    add_text_filter_joins!(view.text_filter, joins)
    add_text_filter_conditions!(view.text_filter, conditions)
      
    # Only apply tag filtering if both the tag filter and current user are provided
    if view.user and (!view.tag_filter[:include].blank? or !view.tag_filter[:exclude].blank?)
      tag_inclusion_filter_by_user = {}
      tag_exclusion_filter_by_user = {}
      
      view.tag_filter[:include].each do |tag_filter|
        if tag_filter =~ /^pub_tag:(\d+)$/
          tagger = TagPublication.find($1)
          
          tag_inclusion_filter_by_user[tagger] ||= []
          tag_inclusion_filter_by_user[tagger] << tagger.tag_id
        else
          tag_inclusion_filter_by_user[view.user] ||= []
          tag_inclusion_filter_by_user[view.user] << tag_filter
        end
      end
      
      view.tag_filter[:exclude].each do |tag_filter|
        if tag_filter =~ /^pub_tag:(\d+)$/
          tagger = TagPublication.find($1)
          
          tag_exclusion_filter_by_user[tagger] ||= []
          tag_exclusion_filter_by_user[tagger] << tagger.tag_id
        else
          tag_exclusion_filter_by_user[view.user] ||= []
          tag_exclusion_filter_by_user[view.user] << tag_filter
        end
      end
      
      
      (tag_inclusion_filter_by_user.keys + tag_exclusion_filter_by_user.keys).uniq.each do |tagger|        
        tagger_condition = tagger_condition_for(tagger, filters[:include_negative], filters[:only_tagger])

        add_tag_filter_joins!(tagger, tagger_condition, joins)
        add_tag_exclusion_conditions!(tagger, tag_exclusion_filter_by_user[tagger], tagger_condition, conditions)
        add_tag_inclusion_conditions!(tagger, tag_inclusion_filter_by_user[tagger], filters[:include_negative], conditions)        
      end
    elsif view.user and view.show_tagged?
      tagger_condition = tagger_condition_for(view.user, filters[:include_negative], filters[:only_tagger])

      add_tag_filter_joins!(view.user, tagger_condition, joins)
      add_tagged_state_conditions!(view.user, filters[:include_negative], conditions)
    end
    
    options[:conditions] = conditions.empty? ? nil : conditions.join(" AND ")
    
    add_always_include_feed_filter_conditions!(view.feed_filter[:always_include], options[:conditions])
    
    options[:joins] = joins.join(" ")
    
    options
  end
  private_class_method :options_for_filters
  
  # Returns an SQL join statement that restricts feed items to those that match a query string
  #
  # Currently uses the a MySQL full text index on the feed_item_contents_full_text table.
  #
  def self.text_filter_join(query)
    "JOIN feed_item_contents_full_text ON " +
        "feed_items.id = feed_item_contents_full_text.id AND " +
        "MATCH(content) AGAINST(#{connection.quote(query)} IN BOOLEAN MODE) "
  end
  
  def self.add_feed_filter_conditions!(feed_filter, conditions)
    if feed_filter
      if !feed_filter[:include].empty?
        conditions << "feed_items.feed_id IN (#{feed_filter[:include].join(",")})"
      end
    
      if !feed_filter[:exclude].empty?
        conditions << "feed_items.feed_id NOT IN (#{feed_filter[:exclude].join(",")})"
      end
    end
  end
  
  # Add any text_filter. This is done using a inner join on feed_item_contents with an
  # additional join condition that applies the text filter using the full text index.
  def self.add_text_filter_joins!(text_filter, joins)
    if text_filter
      joins << "LEFT JOIN feed_item_contents_full_text ON feed_items.id = feed_item_contents_full_text.id"
    end
  end
  
  def self.add_text_filter_conditions!(text_filter, conditions)
    if text_filter
      conditions << "MATCH(content) AGAINST(#{connection.quote(text_filter)} IN BOOLEAN MODE)"
    end
  end

  # First we need to build up the tagger condition.
  # 
  # Start by creating a condition using the tagger types for User and the Classifier.  
  # If :include_negative is false the  strength column is also constrained to be only 
  # positive taggings.
  #
  # Then if :only_tagger is set to either user or classifier, the condition for the tagger
  # we don't need is set to false.
  #
  # Finally combine the user and classifier tagger conditions with a condition that constrains
  # all taggings to have the user_id equal to the id of the user. This is the tagger_condition.
  def self.tagger_condition_for(tagger, include_negative, only_tagger)
    conditions = []
    
    if only_tagger == "user"
      conditions << tagger.tagging_sql(include_negative)
    elsif only_tagger == "classifier"
      conditions << tagger.classifier.tagging_sql(include_negative)
    else
      conditions << tagger.tagging_sql(include_negative)
      conditions << tagger.classifier.tagging_sql(include_negative)
    end
    
    "(#{conditions.join(" OR ")})"
  end
  
  def self.taggings_alias_for(tagger)
    "#{tagger.class.name.downcase}_#{tagger.id}_taggings"
  end
  
  def self.add_tag_filter_joins!(tagger, tagger_condition, joins)
    taggings_alias = taggings_alias_for(tagger)
    
    joins << "LEFT OUTER JOIN taggings #{taggings_alias} ON " <<
             "#{taggings_alias}.taggable_id = feed_items.id AND " <<
             "#{taggings_alias}.taggable_type = 'FeedItem' AND " <<
             "#{taggings_alias}.deleted_at IS NULL AND " <<
             tagger_condition.gsub(/taggings\./, "#{taggings_alias}.")
  end
  
  def self.add_tag_exclusion_conditions!(tagger, tag_filter, tagger_condition, conditions)
    taggings_alias = taggings_alias_for(tagger) + "_excluded"
    
    unless tag_filter.blank?
      
      conditions << <<-EOSQL
        feed_items.id NOT IN(
          SELECT taggable_id FROM taggings #{taggings_alias}
          WHERE #{taggings_alias}.taggable_type = 'FeedItem' 
            AND #{taggings_alias}.deleted_at is NULL 
            AND #{tagger_condition.gsub(/taggings\./, "#{taggings_alias}.")} 
            AND #{taggings_alias}.tag_id IN (#{tag_filter.join(",")})
        )
      EOSQL
    end
  end
  
  def self.add_tag_inclusion_conditions!(tagger, tag_filter, include_negative, conditions)
    taggings_alias = taggings_alias_for(tagger)
    taggings_alias_for_include_negative = taggings_alias_for(tagger) + "_negative"
    
    unless tag_filter.blank?
      tag_conditions = ["#{taggings_alias}.id IS NOT NULL", "#{taggings_alias}.tag_id IN (#{tag_filter.join(",")})"]
      conditions.concat(tag_conditions)
      
      # Finally, when applying normal tag filters if :include_negative is false
      # add another condition overrides classifier assigned tags with any negative
      # tagging by the user.  This ensures that when a user removes a classifier 
      # assigned tag, which has the effect of adding a negative user tag, the classifier
      # assigned tags don't cause the item to be included.
      #
      unless include_negative
        conditions << <<-EOSQL
          feed_items.id NOT IN(
            SELECT taggable_id FROM taggings #{taggings_alias_for_include_negative}
            WHERE #{taggings_alias_for_include_negative}.taggable_type = 'FeedItem' 
              AND #{taggings_alias_for_include_negative}.deleted_at is NULL 
              AND #{taggings_alias_for_include_negative}.tagger_id = #{tagger.id}
              AND #{taggings_alias_for_include_negative}.tagger_type = '#{tagger.class.name}'
              AND #{taggings_alias_for_include_negative}.strength = 0
              AND #{tag_conditions.join(" AND ").gsub(taggings_alias, taggings_alias_for_include_negative)}
          )
        EOSQL
      end
    end
  end
  
  def self.add_tagged_state_conditions!(tagger, include_negative, conditions)
    taggings_alias = taggings_alias_for(tagger)
    taggings_alias_for_include_negative = taggings_alias_for(tagger) + "_negative"
    
    tag_conditions = ["#{taggings_alias}.id IS NOT NULL"]
    conditions.concat(tag_conditions)
    
    # Finally, when applying normal tag filters if :include_negative is false
    # add another condition overrides classifier assigned tags with any negative
    # tagging by the user.  This ensures that when a user removes a classifier 
    # assigned tag, which has the effect of adding a negative user tag, the classifier
    # assigned tags don't cause the item to be included.
    #
    unless include_negative
      conditions << <<-EOSQL
        feed_items.id NOT IN(
          SELECT taggable_id FROM taggings #{taggings_alias_for_include_negative}
          WHERE #{taggings_alias_for_include_negative}.taggable_type = 'FeedItem' 
            AND #{taggings_alias_for_include_negative}.deleted_at is NULL 
            AND #{taggings_alias_for_include_negative}.tagger_id = #{tagger.id}
            AND #{taggings_alias_for_include_negative}.tagger_type = '#{tagger.class.name}'
            AND #{taggings_alias_for_include_negative}.strength = 0
            AND #{tag_conditions.join(" AND ").gsub(taggings_alias, taggings_alias_for_include_negative)}
        )
      EOSQL
    end
end
  
  def self.add_always_include_feed_filter_conditions!(feed_filter, conditions)
    if conditions and !feed_filter.blank?
      conditions.replace "feed_items.feed_id IN (#{feed_filter.join(",")}) OR (#{conditions})"
    end
  end
  
  # Gets the tokens with frequency counts for the feed_item.
  # 
  # This return a hash with token => freqency entries.
  #
  # There are a number of different ways to get the tokens for an item:
  # 
  # The fastest, providing the token already exists, is to select out the 
  # tokens field from the feed_item_tokens_containers table as a field of
  # the feed item. In this case the tokens will be unmarshaled without type
  # casting.
  #
  # You can also include the :latest_tokens association on a query for feed
  # items which will get the tokens with the highest tokenizer version.  This
  # method will require Rails to build the association so it is slower than the 
  # previously described method.
  #
  # Finally, the slowest, but also the method that will create the tokens if the
  # dont exists is to pass version and a block, if there are no tokens matching the 
  # tokenizer version the block is called and a token container will be created
  # using the result from the block as the tokens. This is the method used by
  # FeedItemTokenizer#tokens.
  #
  def tokens_with_counts(version = FeedItemTokenizer::VERSION, force = false)
    if block_given? and force
      tokens = yield(self)
      token_containers.create(:tokens_with_counts => tokens, :tokenizer_version => version)
      tokens
    elsif tokens = read_attribute_before_type_cast('tokens_with_counts')
      Marshal.load(tokens)  
    elsif self.latest_tokens and self.latest_tokens.tokenizer_version == version
      self.latest_tokens.tokens_with_counts
    elsif token_container = self.token_containers.find(:first, :conditions => ['tokenizer_version = ?', version])
      token_container.tokens_with_counts
    elsif block_given?
      tokens = yield(self)
      token_containers.create(:tokens_with_counts => tokens, :tokenizer_version => version)
      tokens
    end
  end
  
  # Gets the tokens without frequency counts.
  #
  # This method requires the tokens to have already been extracted and stored in the token_container.
  # 
  def tokens(version = FeedItemTokenizer::VERSION)
    if tokens = read_attribute_before_type_cast('tokens')
      Marshal.load(tokens)
    elsif self.latest_tokens and self.latest_tokens.tokenizer_version == version
      self.latest_tokens.tokens
    elsif token_container = self.token_containers.find(:first, :conditions => ['tokenizer_version = ?', version])
      token_container.tokens
    end
  end
  
  # Gets a UID suitable for use within the classifier
  def uid 
    "Winnow::FeedItem::#{self.id}"
  end
  
  # Gets the content of this feed.
  # This method will handle generating the feed item content from the xml data
  # if it doesnt already exist on the feed_item_content association.
  def content(force = false)
    unless self.feed_item_content
      self.build_feed_item_content
    end
    self.feed_item_content(force)
  end

  # Get the display title for this feed item.
  def display_title
    if self.content.title and not self.content.title.empty?
      self.content.title
    elsif self.content.encoded_content and self.content.encoded_content.match(/^<?p?>?<(strong|h1|h2|h3|h4|b)>([^<]*)<\/\1>/i)
      $2
    elsif self.content.encoded_content.is_a? String
      self.content.encoded_content.split(/\n|<br ?\/?>/).each do |line|
        potential_title = line.gsub(/<\/?[^>]*>/, "").chomp # strip html
        break potential_title if potential_title and not potential_title.empty?
      end.split(/!|\?|\./).first
    else
      ""
    end
  end
end

